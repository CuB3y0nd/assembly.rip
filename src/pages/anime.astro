---
const uid = process.env.BGMTV_UID ?? "";
const token = process.env.BGMTV_TOKEN ?? "";
const base = "https://api.bgm.tv/v0";

type Cat = "watching" | "wish" | "collect";
type CatNum = 3 | 1 | 2;

interface Image {
	large?: string;
	common?: string;
	medium?: string;
	small?: string;
	grid?: string;
}

interface Subject {
	id: number;
	type: number;
	name: string;
	name_cn: string;
	eps?: number;
	images?: Image;
}

interface CollectionItem {
	subject_id: number;
	subject: Subject;
	ep_status: number;
	type: CatNum;
}

interface CollectionResponse {
	data: CollectionItem[];
	limit: number;
	offset: number;
	total: number;
}

const cats: { key: Cat; name: string; type: CatNum }[] = [
	{ key: "watching", name: "在看", type: 3 },
	{ key: "wish", name: "想看", type: 1 },
	{ key: "collect", name: "看完", type: 2 },
];

async function fetchOnce(type: CatNum): Promise<CollectionItem[]> {
	try {
		const res = await fetch(
			`${base}/users/${uid}/collections?subject_type=2&type=${type}&limit=50`,
			{ headers: { Authorization: `Bearer ${token}` } },
		);

		if (!res.ok) {
			console.error(
				`Bangumi API Error (${type}): ${res.status} ${await res.text()}`,
			);
			return [];
		}

		const json: CollectionResponse = await res.json();

		if (!Array.isArray(json.data)) {
			console.error(`Bangumi API (${type}): Unexpected response format`, json);
			return [];
		}

		return json.data;
	} catch (err) {
		console.error(`Failed to fetch collections for type ${type}:`, err);
		return [];
	}
}

let allDataFetched = true;
const data: Record<Cat, CollectionItem[]> = {
	watching: [],
	wish: [],
	collect: [],
};

try {
	const controller = new AbortController();
	const timeoutId = setTimeout(() => controller.abort(), 10000);

	const fetchPromises = cats.map(({ type }) =>
		Promise.race([
			fetchOnce(type),
			new Promise<CollectionItem[]>((_, reject) =>
				setTimeout(() => reject(new Error(`Timeout for type ${type}`)), 10000),
			),
		]),
	);

	const results = await Promise.all(fetchPromises);
	clearTimeout(timeoutId);

	cats.forEach(({ key }, index) => {
		data[key] = results[index] as CollectionItem[];
	});
} catch (err) {
	console.error("Error fetching all collections:", err);
	allDataFetched = false;
}

import MainGridLayout from "../layouts/MainGridLayout.astro";
---

<MainGridLayout>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-4 sm:px-6 py-6 relative w-full">
      <h1 class="text-2xl font-bold mb-6 dark:text-white">追番</h1>

      {allDataFetched ? (
        <>
          <!-- 标签页导航 -->
          <div class="flex border-b border-gray-200 dark:border-gray-700 mb-6" role="tablist" id="bangumi-tabs">
            {cats.map(({ key, name }, index) => {
              const isFirst = index === 0;
              return (
                <button
                  id={`tab-${key}`}
                  class={`tab-button px-4 py-2 font-medium text-sm transition-colors duration-200 ${
                    isFirst
                      ? 'border-b-2 border-primary text-primary dark:text-[var(--primary)]'
                      : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
                  }`}
                  data-target={key}
                  role="tab"
                  aria-controls={`panel-${key}`}
                  aria-selected={isFirst}
                >
                  {name}（{data[key].length}）
                </button>
              );
            })}
          </div>

          <!-- 标签页内容 -->
          <div class="mt-4 bangumi-content-container">
            {
              cats.map(({ key }, index) => {
                const isFirst = index === 0;
                return (
                  <section
                    id={key}
                    role="tabpanel"
                    aria-labelledby={`tab-${key}`}
                    class={`bangumi-section ${!isFirst ? 'hidden' : ''}`}
                    aria-hidden={!isFirst}
                  >
                    {
                      data[key].length ? (
                        // 使用虚拟滚动优化大量数据的渲染性能
                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                          {data[key].map((item) => {
                            const s = item.subject;
                            const total = s?.eps || 0;
                            const watched = item.ep_status || 0;
                            const percent = total > 0 ? Math.min(100, Math.max(0, Math.round((watched / total) * 100))) : 0;
                            const imageUrl = s?.images?.large || s?.images?.common || '/default-image.png';

                            return (
                              <div class="card-base overflow-hidden transition-transform duration-300 hover:shadow-lg dark:bg-[var(--card-bg)]">
                                <div class="aspect-[3/4] overflow-hidden">
                                  <img
                                    class="w-full h-full object-cover transition-transform duration-300 hover:scale-105"
                                    src={imageUrl}
                                    alt={s?.name || s?.name_cn || '未知番剧'}
                                    loading="lazy"
                                    decoding="async"
                                    data-src-fallback="/default-image.png"
                                  />
                                </div>
                                <div class="p-3">
                                  <h2 class="font-medium text-base line-clamp-2 mb-2 min-h-[2.5rem] dark:text-white break-words">{s?.name || s?.name_cn || '未知番剧'}</h2>
                                  <div class="text-xs">
                                    <div class="flex justify-between mb-1">
                                      <span class="text-gray-600 dark:text-gray-300 truncate">{watched} / {total}</span>
                                      <span class="text-gray-600 dark:text-gray-300">{percent}%</span>
                                    </div>
                                    <!-- 进度条容器 -->
                                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5">
                                      <div
                                        class="h-1.5 rounded-full transition-all duration-300"
                                        style={`width: ${percent}%; background-color: var(--primary)`}
                                      ></div>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      ) : (
                        <div class="text-center py-12 text-gray-500 dark:text-gray-400">
                          暂无数据
                        </div>
                      )
                    }
                  </section>
                );
              })
            }
          </div>
        </>
      ) : (
        <div class="text-center py-12 text-red-500 dark:text-red-400">
          加载数据失败，请稍后重试。
        </div>
      )}
    </div>
  </div>
</MainGridLayout>

<!-- 客户端交互脚本 -->
<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const tabContainer = document.getElementById('bangumi-tabs');
    const contentContainer = document.querySelector('.bangumi-content-container');
    if (!tabContainer || !contentContainer) return;

    const tabs = tabContainer.querySelectorAll('.tab-button');
    const sections = contentContainer.querySelectorAll('.bangumi-section');

    function switchTab(selectedTab) {
      const targetKey = selectedTab.dataset.target;
      tabs.forEach(tab => {
        const isSelected = tab === selectedTab;
        tab.classList.toggle('border-b-2', isSelected);
        tab.classList.toggle('border-primary', isSelected);
        tab.classList.toggle('text-primary', isSelected);
        tab.classList.toggle('dark:text-[var(--primary)]', isSelected);

        if (isSelected) {
          tab.classList.remove('text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-300');
        } else {
          tab.classList.add('text-gray-500', 'hover:text-gray-700');
          tab.classList.remove('text-primary', 'dark:text-[var(--primary)]');
          // 在暗色模式下，非选中标签应该使用暗色模式的默认颜色
          if (document.documentElement.classList.contains('dark')) {
            tab.classList.add('dark:text-gray-400', 'dark:hover:text-gray-300');
          }
        }
        tab.setAttribute('aria-selected', isSelected.toString());
      });
      sections.forEach(section => {
        const isTarget = section.id === targetKey;
        section.classList.toggle('hidden', !isTarget);
        section.setAttribute('aria-hidden', (!isTarget).toString());
      });
    }

    tabs.forEach(tab => tab.addEventListener('click', () => switchTab(tab)));

    // 图片错误处理 - 优化版本
    function handleImageError(img) {
      const fallbackSrc = img.dataset.srcFallback || '/default-image.png';
      const handleError = function() {
        try {
          // 移除事件监听器避免重复触发
          img.removeEventListener('error', handleError);

          // 检查当前src是否已经是fallback图片
          if (img.src !== fallbackSrc) {
            img.src = fallbackSrc;
            img.alt = '图片加载失败';
          }
        } catch (e) {
          console.error('图片加载失败处理出错:', e);
          img.src = fallbackSrc;
          img.alt = '图片加载失败';
        }
      };

      img.addEventListener('error', handleError);
    }

    // 对所有图片应用错误处理
    document.querySelectorAll('img[data-src-fallback]').forEach(handleImageError);

    // 使用 Intersection Observer 优化图片加载
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            // 只对有data-src属性的图片进行懒加载处理
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
            }
            observer.unobserve(img);
          }
        });
      });

      document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
      });
    }
  });
</script>

<!-- 全局样式 -->
<style is:global>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* 响应式优化，确保在手机端也能良好显示 */
  @media (max-width: 640px) {
    .bangumi-section .grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
    }

    .bangumi-section .card-base {
      max-width: 100%;
    }

    .bangumi-section .p-3 {
      padding: 0.5rem;
    }

    .bangumi-section h2 {
      font-size: 0.75rem;
      line-height: 1rem;
      min-height: 2rem;
    }

    .bangumi-section .text-xs {
      font-size: 0.65rem;
    }
  }

  @media (max-width: 400px) {
    .bangumi-section .grid {
      gap: 0.5rem;
    }

    .bangumi-section h2 {
      font-size: 0.65rem;
      line-height: 0.875rem;
      min-height: 1.75rem;
    }
  }
</style>

<!-- Bangumi页面暗色模式样式 -->
